---
id: n8wgse9glwraqiceuqtleav
title: FE Module 10 - Talking to The Back End
desc: "Winc FE module 10"
updated: 1692651804032
created: 1692449797540
---

### 01/02. Internet protocols: HTTP (HyperText Transort Protocol)

[Internet Protocol Wikipedia](https://en.wikipedia.org/wiki/Internet_protocol_suite)

### 03. Request/Response

between client and server
type of HTTP requests we can send to a server:

- Get information from the server
- Send new data to the server.
- Update existing data on the server.
- Delete data from the server. ==> CRUD (Create, Read, Update, Delete)

### 04. URL

Parts of a URL (required and optional):

- Scheme: i.e.: http, https, mailto, ftp etc.
- Host(or hostname): domain names, mapped to IP addresses
  (no necessary one-to-one relationship, multi dom can go to the same IP)
  i.e. www.google.com or, localhost:3000 (localhost is the host name)
  - www > subdomain, can be anything en.wikipedia.com ('en' is the sub.d)
  - google > domain name
  - .com > top-level domain
- Path: after the host/port or domain combination
  can be 0 or more segments:
  "www.google.../search/howsearchworks (2 segments)"
- User info: rare, i.e. "userName:secret"
- Port: usually only in local hosting, but the default for web is port 80
- Query: part after the '?', one or more key/value pairs separated by '&'
  used for simple filtering
  i.e. http://localhost?filter=true&country=us&state=california&city=losangeles
- Fragment: an optional part of the URL
  used to link to a specific part of the page

URLs in the backend

- a common structure pattern is the REST architecture
- resource: anithing that we may want to [C]reate [R]eade [U]pdate [D]elete
- each resource has its own URL, also often for types of resuorces (namespace, collection)
- URLs in this context called endpoints
  Alternatives to REST: GraphQL, JSON: API
  All backend structure uses HTTP

#### E: talk to different URLs - Postman

use restournat.json >> json-erver >> endpoints: localhost:3000/menu, /tables, /reservations

- send GET request,
- modify url with item id,
- add filter queries: URL/endpoint?filterParam=value (num, string..)
- filter for value range URL/endpoint?filterParam_gte=value (num, string..) 'gte > greather than or equal to'

#### E: talk to different URLs - JavaScript

use restournat.json >> json-server >> endpoints: localhost:3000/menu, /tables, /reservations

### 05. Methods

- A request method is part of an HTTP request > 1 method/request
- Methods are allways written in uppercase letters
  :warning: the way a backend uses the methods can vary >> READ THE DOCS to know the exact way
  [more info](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)

#### 05.01. GET (= read) & DELETE

- for retrieving (reading) data only
- can be sent to a namespace URL or a specific resource
- response is some data or an error if the backend does not now the request (> status codes)
  In JS inside an `async` function >> i.e.:

```javascript
const sendRequest = async () => {
  const response = await fetch("URL", { options_obj }); //*
  const json = await response.json();
  return json;
};
```

- \*options_object: i.e.: `{method: "DELETE"}` >> `GET` if no options object

### 06. Status codes

- they tell us how the backend handeled a request
- it is a number between 100 & 599
- they also have a short name (for display, not in the code)
  i.e.: '200 OK' or '404 Not Found'
  JS: use the status property of the response object

```javascript
const response = await fetch("http://localhost:3000/menu/5");
console.log(response.status); //200
```

#### Most used statuscodes:

- 200 OK **&rArr;** request handled successfuly
- 201 Created **&rArr;** successful request,
- 401 Unauthorized **&rArr;** request without or with wrong auth details
- 403 Forbidden **&rArr;** system sending the request is not authorized to read the resource or perform the operation on it
- 404 Not Found **&rArr;** resource the request was aiming at could not be found on the json-server
- 429 Too Many Requests **&rArr;** too many requests from the same source
- 500 Internal Server Error **&rArr;** backend has an unrecoverable problem while processing the request

### 07. Response body

#### 07.01. POST method

Postman >> in the response body (raw, JSON) include i.e.: a JSON object

```javascript
{
  "prop" : "val",
  "prop" : "val",
  "prop" : "val",
}
```

this will add a new object to the backend JSON file
(id is generated by the backend)

#### 07.02. PUT & PATCH method

Postman >> in the response body (raw, JSON) include i.e.: a JSON object

```javascript
{
  "prop" : "val",
  "prop" : "newVal",
  "prop" : "val",
}
```

this will replace the whole JSON object in the backend JSON file
The backend usually walidates the object in the PUT body

#### 07.03. POST, PUT and PATCH methods (JavaScript)

Opton obj for `fetch` should include:

- a body
- a specific header

* :warning: Can't add a body to a GET with fetch (query params included in the query part of the URL)
  FORMAT EXAMPLE:

```javascript
fetch("URL", {
  method: "POST",
  body: '{"a":1}',
  headers: {
    "Content-Type": "application/json;charset=utf-8",
  },
});
```

"POST" a new resource object will be created on the backend from the body
"PUT" the whole resource object will be replaced with the body
"PATCH" only whats included in the body will be changed, won't delete what is not in the body

### 08. Headers

- info about the messagei (message type, body type, message lifetime, authentication...),
- part of the message,
- both req. and res. can have headers
- std. header or custom header,
  [more info](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)

#### 08.03. Request and Response headers

##### Request Header Examples:

- The Accept header (what content type the sender(client) accepts, single or multiple values
  `Accept: text/html`  
   `Accept: */*`  
   `Accept:   
text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,    
*/*;q=0.8,application/signed-exchange;v=b3;q=0.9`

- The Accept-Language header (client preffered human langs and locals)  
  `Accept-Language: de` for German, not specified to a country  
  `Accept-Language: nl-NL` for Dutch in the Netherlands  
  `Accept-Language: es_PE` for Peruvian Spanish

- The Authorization header is used to send “credentials” to the server.  
  `Authorization: Basic taHDUsyEoZrxLTgkb7Ff`  
  `Authorization: Bearer CMn0QUmeH2miABK0d6qQ`

- The Host header is a required and essential header.  
  contains the host and, optionally, the port the message is sent to  
  `Host: localhost:3000`  
  `Host: www.bbc.com`  
  `Host: en.wikipedia.org`

- The User-Agent (or UA) header gives the receiver information about what kind of  
   system the sender is.  
   `User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0`  
   `User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko)   
Chrome/51.0.2704.103 Safari/537.36`  
   `User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0;   
IEMobile/9.0)`

##### Rresponse Header Examples:

- The Content-Language Header  
  describes the language of the document  
  `Content-Language: pt-BR` for Brazilian Portuguese.  
  `Content-Language: en-CM` for English from the country Cameroon  
  `Content-Language: nl-BE` for Belgian Dutch

##### Request and Rresponse Header Examples:

- The Cache-Control Header  
  contain instructions for the receiver on how to “cache” the content of the message  
  saving a received message locally so you don’t need to ask for it again which improves performance.  
  `Cache-Control: no-store`  
  `Cache-Control: public, max-age=86400`  
  `Cache-Control: public, min-fresh=3153600`

- The Content-Langth Header  
  communicates the size of the message body in bytes  
  `Content-Length: 42`  
  `Content-Length: 544`  
  `Content-Length: 256808`

- The Content Type Header  
  communicates the type of resource being sent  
  `Content-Type: text/html; charset=utf-8`  
  `Content-Type: text/css`  
  `Content-Type: image/png`  
  `Content-Type: application/json`

- The Expires Header  
  communicates to the receiver when the response will expire  
  `Expires: Wed, 21 Oct 2015 07:28:00 GMT`  
  `Expires: Thu, 2 Dec 2023 10:43:00 GMT`  
  `Expires: Mon, 17 Jan 2022 17:12:00 GMT`

##### Exercise: inspect headers in browser devtools

- headers tab in network tab
- same for Postman **&rArr;** add custom header {key:value}

#### 08.06. Exercise: inspect headers in JavaScript

- headers property of the response object is a headers object
- log all headers from response:

```javascript
const response = await fetch("http://localhost:3000");
for (const [header, value] of response.headers.entries()) {
  console.log(`${header}: ${value}`);
}
```

- check if a specific header exists(.has), check header value(.get):

```javascript
const response = await fetch("http://localhost:3000/tables");
const headers = response.headers;
let contentType;
if (headers.has("content-type")) {
  contentType = headers.get("content-type");
}
console.log(contentType); //application/json: charset=utf-8
```

#### 08.07. Setting headers in fetch

- to set custom header in a request add headers prop to options object we pass to fetch

```javascript
const url = "https://www.example.com";
const body = { a: 1 };
const options = {};
options.method = "POST";
options.body = JSON.sringify(body);
options.headers = {
  Expires: "Thu, 2 Dec 2023 10:43:00 GMT",
  "Content-Type": "application/json;charset=utf-8",
};
fetch(url, options);
```

#### 08.08. Exercise: set headers in JavaScript

use syntax from above to add header to request body - inside options object for fetch()

### 09. Separating business logic from UI and IO

- better readability
- better maintainability  
  i.e. makes adding new logic easier, debugging easier etc.
- makes switching frameworks easier
- makes writing tests easier (separate test for IO, UI, b. logic)

### 10. Async / Await - Asynchronous JavaScript

- keep the program running while it is waiting for a server response
- if an async function returns a value we have to await that value... othervise it is undefined.
  i.e:

```javascript
async function getData() {
  //asynchronous function declaration
  return 42;
}

const data = await getData(); // data is 42;
```

for server requests, the fetch method has to be wrapped in an async function,  
and the response has to be awaited. Also, each async function has to be awaited:

```javascript
async function fetchData() {
  try {
    const response = await fetch("http://localhost:3000/todo");
    const todos = await response.json();
    console.table(todos);
  } catch (error) {
    console.error("no todos found");
  }
}
fetchData();
```

#### 10.04. Common Async Patterns

##### Pitfall of async code in JS:

- `await` blocks the code until it is resolved so awaiting at the top level of our code is not a good idea, it is better to await things when it is actually needed
- anything that depends on the result of await should be handled inside the async function itself. (with multiple, interdependent functions this can get complicated quickly **&rArr;** everything is async)

##### Avoid having async functions everywhere:

**Inversion of control**:  
instead of caller function we let the async function handle the result from the asynchronous code. i.e.:

```javascript
async function handleData() {
  const data = await fetchData();
  showData(data); // synchronous function, async spreading is stopped
}
```

:warning: It is important to contain async code

The sync and async code should be separated as much as possible. The rest of the code  
that has nothing to do with the async data should run independently. >> DO NOT await  
async code at the top level (EXECEPTION EXIST).

All the awaiting happens inside the async function which is not awaited itself **&rArr;** as soon it hits an await the the control flow is handeled back to wherever the  
async function was called **&rArr;** rest of the code continues to execute (concept - EVENT LOOP)

##### Successive async function calls (async code depends on other async code)

i.e.: make request based on prev requested data

```javascript
async function handlePosts() {
  const user = await fetchUser();
  cosnt posts = await fetchPosts(user.id);
  showPosts(posts); // regular sync function
}
```

##### Multiple independent async code **&rArr;** paralel requests >> do not await them in succession

i.e.:

```javascript
async function handlePosts() {
  const asyncFriends = fetchFriends(); // no await
  cosnt asyncPosts = fetchPosts(user.id); // no await
  // both requests have been fired

  // await the posts
  showPosts(await asyncPosts);
  // await friends
  showFriends(await asyncFriends);
}
```

The fetche's result (a promise) is stored in a constant.  
We do not have to immediately await an async function in order to get the data out of it.  
We can keep a reference to the Promise and await it later on

##### Different requests can take different time (some times big diff)

- each requests should be handled as the result comes in
- wrap them individually an async function
- call them independently and handle them in the order they come in

```javascript
async function handleRequests() {
  async function hadleFriends() {
    const friends = await fetchFriends();
    showFriends(friends);
  }

  async function handlePosts() {
    const posts = await fetchPosts();
    showPosts(posts);
  }

  await Promise.all([
    // takes an array of promisses and resolvs when all of them are resolved
    handlePosts(), // returns a single promise, aggregating the results of multiple promisses __&rArr;__ used with relaterd promisses
    handleFriends(),
  ]);
}
```

[more about Promise.all](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)

##### Top level await

It is possible to awati at the top level of a JS module, **HOWEVER**:

- a module with top level await will be awaited by other modules when they import it so it sort of blocks the execution (other imported synchronous modules will run tho)
  :warning: **Only use top level await in modules that are strictly used for fetching some data and exporting it, and never place synchronous code after your asynchronous code when using top-level await (unless you need the result of the asynchronous code).**

EXTRA RESOURCES for async/await:

- [Async function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
- [Await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)

### 11. Promises

(async/await is built on top of promises)

- Promise: a special type of object that holds a future value (not yet now at that point in the code execution)

Async/Await is preferred ower Promises => more modern, promises are used in older codebases, libraries

The different state of promises:

- pending : at the time when it is created
- fulfilled
- rejected

They can be created in multiple ways:

- using 'fetch' > fetch automatically returns a promise
- each async function returns a promise
- they are object with methods and we can create them ourselves by using the 'new' keyword (but this is increasingly rare, mostly done in library code)

```javascript
const amILucky = new Promise((resolve, reject) => {
  if (Math.random() < 0.99) {
    reject(new Error('You ain't lucky'));
  }
  resolve('You're lucky!);
});
```

there is a specific way to define what happens when a p. is fulfilled or rejected:

1. .then() method **&rArr;** takes the Promise value as its argument
   ```javascript
   amILucky.then((fulfilledValue) => console.log(fulfilledValue));
   ```
2. handling errors can be done in two ways: using .then() or using .catch():
   ```javascript
   amILucky
    .then((fulfilledValue) => console.log(fulfilledValue));
    .catch((error) => console.log('some message', error));
   ```

#### Chaining Promises

both .then() and .catch() return new promises > so we can chain several of them together  
This allows for complex code i.e. performing several requests in succession.

```javascript
fetch("http://localhost:3000/todo")
  .then((response) => response.json())
  .then((todos) => console.table(todos))
  .catch((error) => console.error("no todos found!"));
```

[Promises - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)  
[Using Promises - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)

### 12. Event Loop

- The event loop is a loop where the code can be scheduled
- The most simple example is the setTimeout() function > schedules code, code runs after set time, time unit is ms.

```javascript
setTimeout(() => {
  alert("at least 1 second has passed");
}, 1000);
```

- but also there are requestAnimationTimeframe and micro tasks which get executed in different times in relation to the browser page-rendering
  and their execution also depends on the state of the JS callstack. >> can get complicated and lead to unexpected rendering

[YT vid - Jake Archibald](https://www.youtube.com/watch?v=cCOL7MC4Pl0)  
[MDN - event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)

### 13. Render API response in DOM

```mermaid
%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'primaryColor': '#BB2528',
      'primaryTextColor': '#fff',
      'primaryBorderColor': '#7C0000',
      'lineColor': '#000000',
      'secondaryColor': '#336189',
      'tertiaryColor': '#fff'
    }
  }
}%%

flowchart   LR
id1[Browser \n with \n DOM]
id2[User \n interaction]
id3[UI output]
id4[Application \n logic \n a.k.a. \n business \n rules]
id5[Input]
id6[Output]
id7[Backend]

classDef container fill: #9f9f9f, color: transparent
classDef app color:#000, fill:transparent, stroke:#000, stroke-dasharray: 5 5
classDef s3 fill:transparent, stroke: #2f2f2f
classDef s1 fill:transparent, stroke: #252525, color:transparent
classDef s2 fill:transparent, stroke: #353535, color:transparent
classDef s3 fill:transparent, stroke: transparent, color:#000

container:::container
subgraph container
direction LR
    Browser:::s1
    subgraph Browser
        id1:::s3
    end
    APP:::app
    subgraph APP
    direction TB
        UI:::s2
        subgraph UI
            direction TB
            id2:::s3 -.- id3:::s3
        end
        LOGIC:::s2
        subgraph LOGIC
            id4:::s3
        end
        I/O:::s2
        subgraph I/O
            direction TB
            id5:::s3 -.- id6:::s3
        end
    end
Server:::s1
    subgraph Server
      id7:::s3
    end
end

Browser --Events--> UI --Action \n + \n Data --> LOGIC --Action \n + \n Data --> I/O --Changes--> Server --Current\nData--> I/O --Data--> LOGIC --Data--> UI --DOM\nChanges\n+HTML--> Browser

```

**good place to start where the least connections & interdependencies are between the diff parts**

- not a lot of other code is needed for this part and testing is easier too
- from the diagram these are: IO for sending or retrievieng, UI part where we render HTML based on data

**or places/features that are close to user interaction**

- i.e.: code that listens to and processes events, easy testing, easy to see if we input the right data
- diagram: user interaction part

**start with the "happy path", scenario when everithing works with realistic input**

- start with the easy part
- dont worry about edge cases and diff errors

When all that is done, focus on code for when things go wrong:

- validating user input
- showing validation results
- handling errors and displaying error messages correctly

Happy path in the diagram: app logic/business rules w/o validation, IO without catching errors

:warning: check if the code is woring before and after adding new features to it

? END DETOUR ?

#### Exercise: API response rendering
